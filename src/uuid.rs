//! An interface to manage construction of unique clonable handles
//!
//! A graph structure might be cyclic, and has no clear notion of ownership. Nonetheless, some kind
//! of reference is needed to implement the graph. This module provides an interface to create
//! generic name handles to act as references to vertices in a graph structure. This interface is
//! used only when the handles are generated by the graph structure when a new vertex is created.
//! The users can also build a graph structure which doesn't manage the handles internally, and
//! provide the handle at the time of vertex creation.

use std::cmp::Ord;
use std::borrow::Borrow;

/// The Unit factory. The graph doesn't manage the vertex handles itself, and ask for a handle to
/// the user at the vertex creation.
#[derive(Default)]
pub struct UnitFactory;

/// A handle factory for a graph structure internally managing the handles, but not using an user
/// provided factory. For this kind of graph, handles are usually integer and are managed by the
/// graph code itself.
#[derive(Default)]
pub struct InternalFactory;

/// A handle factory for a graph structure internally managing the handles.
#[derive(Default)]
pub struct Factory<F> {
    pub f : F,
}

impl<F : UUIDFactory>  UUIDFactory for Factory<F> {
    type UUID = F::UUID;

    #[inline(always)]
    fn fresh(&mut self) -> Option<F::UUID> {
        self.f.fresh()
    }
}


/// A vertex handle factory.
pub trait UUIDFactory {
    /// The type of a vertex handle. A vertex handle has to be clonable and the clone will refere
    /// to the same vertex.
    type UUID : Clone;

    /// Generate a fresh unique handle.
    ///
    /// Return `None` if no such handle can be constructed.
    fn fresh(&mut self) -> Option<Self::UUID>;
}

/// A vertex handle factory with a state able to check if a handle is valid (ie has already been
/// returned by the factory.
///
/// This trait is useful to implement counters.
pub trait StableUUIDFactory : UUIDFactory {
    /// Returns true if the given handle is a valid handle which has been constructed by the
    /// factory in the past.
    fn exists<Q>(&self, uuid : &Q) -> bool where Self::UUID : Borrow<Q>, Q : Ord;
}

impl UUIDFactory for u32 {
    type UUID = u32;

    fn fresh(&mut self) -> Option<u32> {
        self.checked_add(1)
            .map(|x| { *self = x; x - 1 })
    }
}

impl UUIDFactory for usize {
    type UUID = usize;

    fn fresh(&mut self) -> Option<usize> {
        self.checked_add(1)
            .map(|x| { *self = x; x - 1})
    }
}

impl<I : UUIDFactory<UUID = I> + Ord> StableUUIDFactory for I {
    fn exists<Q>(&self, uuid : &Q) -> bool where I : Borrow<Q>, Q : Ord {
        uuid < self.borrow()
    }
}
